/*****************************************************************************
 * Copyright (C) 2009-2014    this file is part of the NPTool Project        *
 *                                                                           *
 * For the licensing terms see $NPTOOL/Licence/NPTool_Licence                *
 * For the list of contributors see $NPTOOL/Licence/Contributors             *
 *****************************************************************************/

/*****************************************************************************
 * Original Author: Adrien MATTA  contact address: matta@lpccaen.in2p3.fr    *
 *                                                                           *
 * Creation Date  : march 2015                                               *
 * Last update    :                                                          *
 *---------------------------------------------------------------------------*
 * Decription:                                                               *
 * Class describing the property of an Analysis object                       *
 *                                                                           *
 *---------------------------------------------------------------------------*
 * Comment:                                                                  *
 *                                                                           *
 *                                                                           *
 *****************************************************************************/
#include<iostream>
using namespace std;
#include"Analysis.h"
#include"NPAnalysisFactory.h"
#include"NPDetectorManager.h"
#include"NPOptionManager.h"
#include"RootOutput.h"
#include"RootInput.h"
////////////////////////////////////////////////////////////////////////////////
Analysis::Analysis(){
}

////////////////////////////////////////////////////////////////////////////////
Analysis::~Analysis(){
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::Init(){
  M2 = (TMust2Physics*) m_DetectorManager->GetDetector("M2Telescope");
  SSSD = (TSSSDPhysics*) m_DetectorManager->GetDetector("SSSD");
  Initial = new TInitialConditions();
  ReactionConditions = new TReactionConditions(); 
  InitOutputBranch();
  InitInputBranch();
  Rand = TRandom3();
  He10Reaction= new NPL::Reaction();
  He10Reaction->ReadConfigurationFile(NPOptionManager::getInstance()->GetReactionFile());
  DetectorNumber = 0 ;
  ThetaNormalTarget = 0 ;
  ThetaM2Surface = 0; 
  X_M2 = 0 ;
  Y_M2 = 0 ;
  Z_M2 = 0 ;
  Si_E_M2 = 0 ;
  CsI_E_M2 = 0 ; 
  E_SSSD = 0 ;
  Energy = 0;
  E_M2 = 0;
  Si_X_M2 = 0;
  Si_Y_M2 = 0;
  TargetThickness = m_DetectorManager->GetTargetThickness();
  //	Energy loss table: the G4Table are generated by the simulation
  He3CD2  = EnergyLoss("Example/He3_CD2.G4table","G4Table",100 );
  He3Al   = EnergyLoss("Example/He3_Al.G4table","G4Table",10);
  He3Si   = EnergyLoss("Example/He3_Si.G4table","G4Table",10);
  Li11CD2 = EnergyLoss("Example/Li11_CD2.G4table","G4Table",100);
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::TreatEvent(){
  // Reinitiate calculated variable
  ReInitValue();
  // Get the Original condition for the record
  OriginalELab = ReactionConditions->GetKineticEnergy(0);
  OriginalThetaLab = ReactionConditions->GetTheta(0);
  OriginalBeamEnergy = ReactionConditions->GetBeamEnergy();
  ReactionVertexX = ReactionConditions->GetVertexPositionX(); 
  ReactionVertexY = ReactionConditions->GetVertexPositionY(); 
  ReactionVertexZ = ReactionConditions->GetVertexPositionZ(); 
  // Get the Init information on beam position and energy
  // and apply by hand the experimental resolution
  // This is because the beam diagnosis are not simulated
  // PPAC position resolution on target is assumed to be 1mm
  double XTarget = Initial->GetIncidentPositionX();
  double YTarget = Initial->GetIncidentPositionY();
  double ZTarget = Initial->GetIncidentPositionZ();
  
  // Get the beam direction and position at entrance of the world
  TVector3 BeamDirection = Initial->GetBeamDirection();
  TVector3 BeamPosition(XTarget,YTarget,ZTarget);
 
  // Get the Beam position on Target 
  BeamPosition+=abs(ZTarget)*BeamDirection;
  
  // Randomize beam position on target to simulate PPAC response
  BeamPosition.SetX(Rand.Gaus(BeamPosition.X(),1));
  BeamPosition.SetY(Rand.Gaus(BeamPosition.Y(),1));
  BeamPosition.SetZ(0);
  XTarget = BeamPosition.X();
  YTarget = BeamPosition.Y();
  ZTarget = 0;
  
  // Beam energy is measured using F3 and F2 plastic TOF with 4.5 MeV Resolution
  BeamEnergy = Rand.Gaus(Initial->GetIncidentInitialKineticEnergy(),4.5);
  BeamEnergy = Li11CD2.Slow(BeamEnergy,TargetThickness*0.5,0);
  He10Reaction->SetBeamEnergy(BeamEnergy);
  
  //////////////////////////// LOOP on MUST2 + SSSD Hit //////////////////
  for(unsigned int countSSSD = 0 ; countSSSD < SSSD->Energy.size() ; countSSSD++){
    for(unsigned int countMust2 = 0 ; countMust2 < M2->Si_E.size() ; countMust2++){
      /************************************************/
      //Part 0 : Get the usefull Data
      // MUST2
      int X = M2->Si_X[countMust2];
      int Y = M2->Si_Y[countMust2];
      int TelescopeNumber = M2->TelescopeNumber[countMust2];
      Si_X_M2 = X ;
      Si_Y_M2 = Y ;
      //SSSD
      int SiNumber = SSSD->DetectorNumber[countSSSD];

      /************************************************/
      // Matching between Thin Si and MUST2, and Forward Telescope Only
      if(TelescopeNumber==SiNumber && TelescopeNumber<5){
        DetectorNumber = TelescopeNumber ;
        /************************************************/
        // Part 1 : Impact Angle
        ThetaM2Surface = 0;
        ThetaNormalTarget = 0;
        if(XTarget>-1000 && YTarget>-1000){
          TVector3 BeamImpact(XTarget,YTarget,0);
          TVector3 HitDirection = M2 -> GetPositionOfInteraction(countMust2) - BeamImpact ;
          ThetaLab = HitDirection.Angle( BeamDirection );

          ThetaM2Surface = HitDirection.Angle(- M2 -> GetTelescopeNormal(countMust2) );
          ThetaNormalTarget = HitDirection.Angle( TVector3(0,0,1) ) ;
          X_M2 = M2 -> GetPositionOfInteraction(countMust2).X() ;
          Y_M2 = M2 -> GetPositionOfInteraction(countMust2).Y() ;
          Z_M2 = M2 -> GetPositionOfInteraction(countMust2).Z() ;
        }

        else{
          BeamDirection = TVector3(-1000,-1000,-1000);
          ThetaM2Surface    = -1000  ;
          ThetaNormalTarget = -1000  ;
        }

        /************************************************/

        /************************************************/

        // Part 2 : Impact Energy
        Energy = ELab = E_M2 = 0;
        Si_E_M2 = M2->Si_E[countMust2];
        CsI_E_M2= M2->CsI_E[countMust2];
        E_SSSD = SSSD->Energy[countSSSD];

        // if CsI
        if(CsI_E_M2>0 ){
          // The energy in CsI is calculate form dE/dx Table because 
          Energy = 
            He3Si.EvaluateEnergyFromDeltaE(Si_E_M2,300*micrometer,
                ThetaM2Surface, 0.01*MeV, 
                450.*MeV,0.001*MeV ,1000);
          E_M2=CsI_E_M2;
        }

        else
          Energy = Si_E_M2;

        E_M2 += Si_E_M2;

        // Evaluate energy using the thickness 
        ELab = He3Al.EvaluateInitialEnergy( Energy , 2*0.4*micrometer , ThetaM2Surface); 
        ELab = He3Si.EvaluateInitialEnergy( ELab   , 20*micrometer    , ThetaM2Surface);
        ELab = He3Al.EvaluateInitialEnergy( ELab   , 0.4*micrometer   , ThetaM2Surface);
        // Target Correction
        ELab = He3CD2.EvaluateInitialEnergy( ELab ,TargetThickness*0.5, ThetaNormalTarget);
        /************************************************/

        /************************************************/
        // Part 3 : Excitation Energy Calculation
        Ex = He10Reaction -> ReconstructRelativistic( ELab , ThetaLab );
        /************************************************/


        /************************************************/
        // Part 4 : Theta CM Calculation
        ThetaCM  = He10Reaction -> EnergyLabToThetaCM( ELab , ThetaLab)/deg;
        ThetaLab=ThetaLab/deg;
        /************************************************/
      
      }
    } //end loop SSSD
  }//end loop MUST2
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::End(){
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::InitOutputBranch() {
  RootOutput::getInstance()->GetTree()->Branch("Ex",&Ex,"Ex/D");
  RootOutput::getInstance()->GetTree()->Branch("ELab",&ELab,"ELab/D");
  RootOutput::getInstance()->GetTree()->Branch("ThetaLab",&ThetaLab,"ThetaLab/D");
  RootOutput::getInstance()->GetTree()->Branch("ThetaCM",&ThetaCM,"ThetaCM/D");
  RootOutput::getInstance()->GetTree()->Branch("BeamEnergy",&BeamEnergy,"BeamEnergy/D"); 
  RootOutput::getInstance()->GetTree()->Branch("OriginalELab",&OriginalELab,"OriginalELab/D");
  RootOutput::getInstance()->GetTree()->Branch("OriginalThetaLab",&OriginalThetaLab,"OriginalThetaLab/D");
  RootOutput::getInstance()->GetTree()->Branch("OriginalBeamEnergy",&OriginalBeamEnergy,"OriginalBeamEnergy/D");
  RootOutput::getInstance()->GetTree()->Branch("ReactionVertexX",&ReactionVertexX,"ReactionVertexX/D");
  RootOutput::getInstance()->GetTree()->Branch("ReactionVertexY",&ReactionVertexY,"ReactionVertexY/D");
  RootOutput::getInstance()->GetTree()->Branch("ReactionVertexZ",&ReactionVertexZ,"ReactionVertexZ/D");
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::InitInputBranch(){
  RootInput:: getInstance()->GetChain()->SetBranchStatus("InitialConditions",true );
  RootInput:: getInstance()->GetChain()->SetBranchStatus("fIC_*",true );
  RootInput:: getInstance()->GetChain()->SetBranchAddress("InitialConditions",&Initial);
  RootInput:: getInstance()->GetChain()->SetBranchStatus("ReactionConditions",true );
  RootInput:: getInstance()->GetChain()->SetBranchStatus("fRC_*",true );
  RootInput:: getInstance()->GetChain()->SetBranchAddress("ReactionConditions",&ReactionConditions);
}

////////////////////////////////////////////////////////////////////////////////     
void Analysis::ReInitValue(){
  Ex = -1000 ;
  ELab = -1000;
  ThetaLab = -1000;
  BeamEnergy = -1000;
  ThetaCM = -1000;
  OriginalELab = -1000;
  OriginalThetaLab = -1000;
  
}

////////////////////////////////////////////////////////////////////////////////
//            Construct Method to be pass to the DetectorFactory              //
////////////////////////////////////////////////////////////////////////////////
NPL::VAnalysis* Analysis::Construct(){
  return (NPL::VAnalysis*) new Analysis();
}

////////////////////////////////////////////////////////////////////////////////
//            Registering the construct method to the factory                 //
////////////////////////////////////////////////////////////////////////////////
extern "C"{
class proxy{
  public:
    proxy(){
      NPL::AnalysisFactory::getInstance()->SetConstructor(Analysis::Construct);
    }
};

proxy p;
}

